<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code IDE Integration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #252526;
            padding: 15px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header button {
            padding: 8px 16px;
            background-color: #0e639c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .header button:hover {
            background-color: #1177bb;
        }

        .header button:active {
            background-color: #0d5a8f;
        }

        .header input[type="file"] {
            display: none;
        }

        .header label {
            padding: 8px 16px;
            background-color: #0e639c;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .header label:hover {
            background-color: #1177bb;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            gap: 1px;
            background-color: #3e3e42;
        }

        .left-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            gap: 1px;
            background-color: #3e3e42;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #1e1e1e;
        }

        .error-panel {
            height: 150px;
            flex: 0 0 150px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #1e1e1e;
        }

        .panel-header {
            background-color: #252526;
            padding: 10px 15px;
            border-bottom: 1px solid #3e3e42;
            font-weight: bold;
            font-size: 14px;
        }

        .panel-content {
            flex: 1;
            overflow: auto;
            padding: 15px;
        }

        .error-panel-content {
            flex: 1;
            overflow: auto;
            padding: 10px 15px;
            font-size: 13px;
        }

        /* Overlay highlighter */
        #codeEditorContainer { position: relative; width: 100%; height: 100%; }
        #highlightedCode {
            position: absolute; inset: 0; overflow: auto; padding: 10px;
            font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5;
            color: #d4d4d4; white-space: pre-wrap; word-wrap: break-word; pointer-events: none;
            background: #1e1e1e; z-index: 0;
        }
        #codeEditor {
            position: relative; z-index: 1; width: 100%; height: 100%;
            background: transparent; color: transparent; caret-color: #d4d4d4;
            border: none; outline: none; resize: none; padding: 10px;
            font-family: 'Courier New', monospace; font-size: 14px; line-height: 1.5;
        }
        #codeEditor::selection { background-color: #264f78; }

        /* Comments */
        .token-comment { color: #7a7e85; font-style: italic; }

        /* Control flow keywords (purple/magenta) */
        .token-control-flow { color: #c586c0; font-weight: bold; }

        /* Declaration keywords (orange) */
        .token-declaration { color: #cf8e6d; font-weight: bold; }

        /* Reference keywords (blue) */
        .token-reference { color: #4fc1ff; font-weight: bold; }

        /* Type operators (cyan) */
        .token-type-operator { color: #4ec9b0; font-weight: bold; }

        /* Generic keywords (light orange) */
        .token-keyword { color: #cf8e6d; }

        /* Visibility modifiers (yellow/gold) */
        .token-visibility { color: #dcdcaa; font-style: italic; }

        /* Class modifiers (bright orange) */
        .token-class-modifier { color: #ff9933; font-style: italic; }

        /* Function modifiers (light orange) */
        .token-function-modifier { color: #d4a574; font-style: italic; }

        /* Parameter modifiers (light blue) */
        .token-parameter-modifier { color: #9cdcfe; font-style: italic; }

        /* Platform modifiers (pink) */
        .token-platform-modifier { color: #ff66cc; font-style: italic; }

        /* Annotation targets (light purple) */
        .token-annotation-target { color: #b8a3d6; }

        /* Literals (light blue) */
        .token-literal { color: #569cd6; font-weight: bold; }

        /* Strings */
        .token-string { color: #6aab73; }

        /* Numbers */
        .token-number { color: #b5cea8; }

        /* Brackets (bright yellow) */
        .token-bracket { color: #ffd700; font-weight: bold; }

        /* Annotations (yellow/gold) */
        .token-annotation { color: #bbb529; }

        /* Operators (white) */
        .token-operator { color: #d4d4d4; }

        /* Punctuation (light gray) */
        .token-punctuation { color: #bbbbbb; }

        /* Identifiers */
        .token-identifier { color: #d4d4d4; }

        /* Default */
        .token-default { color: #d4d4d4; }

        /* Errors */
        .token-error { color: #f44747; text-decoration: underline wavy #f44747; }

        /* Clickable error links */
        .error-link {
            color: #f44747;
            text-decoration: underline;
            cursor: pointer;
            transition: color 0.2s;
            display: block;
        }

        .error-link:hover {
            color: #ff6b6b;
        }

        /* Error highlight animation */
        .error-highlight {
            background-color: rgba(255, 71, 71, 0.3);
            animation: fadeOut 1s forwards;
        }

        @keyframes fadeOut {
            0% { background-color: rgba(255, 71, 71, 0.5); }
            100% { background-color: transparent; }
        }

        /* Loading spinner */
        .loading-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
            gap: 20px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #3e3e42;
            border-top: 4px solid #0e639c;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #9cdcfe;
            font-size: 14px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        /* Validation messages */
        .validation-message {
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
            white-space: pre-wrap;
        }

        .validation-loading {
            color: #9cdcfe;
        }

        .validation-success {
            color: #4ec9b0;
        }

        .validation-error {
            color: #f44747;
        }
    </style>
</head>
<body>
<div class="header">
    <label for="fileUpload">Upload File</label>
    <input type="file" id="fileUpload" accept=".kts">
    <button id="runButton">Run Code</button>
</div>

<div class="container">
    <div class="left-section">
        <div class="panel">
            <div class="panel-header">Editor Panel</div>
            <div class="panel-content scrollbar">
                <div id="codeEditorContainer">
                    <div id="highlightedCode" class="scrollbar"></div>
                    <textarea id="codeEditor" placeholder="Paste your code here or upload a file..." spellcheck="false"></textarea>
                </div>
            </div>
        </div>
        <div class="error-panel">
            <div class="panel-header">Errors</div>
            <div class="error-panel-content scrollbar" id="errorPanel">
                <div class="validation-message validation-loading">Ready for code input...</div>
            </div>
        </div>
    </div>
    <div class="panel">
        <div class="panel-header">Output Panel</div>
        <div class="panel-content scrollbar" id="resultPanel">
            <div style="color: #7a7e85; font-style: italic;">Output will appear here when you run code...</div>
        </div>
    </div>
</div>

<script>
    const codeEditor = document.getElementById('codeEditor');
    const highlightedCode = document.getElementById('highlightedCode');
    const resultPanel = document.getElementById('resultPanel');
    const errorPanel = document.getElementById('errorPanel');
    const fileUpload = document.getElementById('fileUpload');
    const runButton = document.getElementById('runButton');

    const PARSE_DEBOUNCE_MS = 300; // faster response for better UX

    let validationTimeout;
    let currentController = null;
    let docVersion = 0; // increment on each edit
    let lastCode = '';
    let lastHighlightedCode = '';

    // ...existing code...

    // Initial state
    renderStatus('Ready for code input...', 'loading');

    // Scroll sync (passive for smoother scrolling)
    codeEditor.addEventListener('scroll', () => {
        highlightedCode.scrollTop = codeEditor.scrollTop;
        highlightedCode.scrollLeft = codeEditor.scrollLeft;
    }, { passive: true });

    // Upload
    fileUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (event) => {
            codeEditor.value = event.target.result;
            handleInputChange();
        };
        reader.readAsText(file);
    });

    // Instant visual update - preserve colors while typing
    codeEditor.addEventListener('input', handleInputChange);
    function handleInputChange() {
        docVersion++;
        const code = codeEditor.value;

        // Immediate update: show all text with preserved highlighting where possible
        updateOverlayFast(code);

        // Debounced server parsing for accurate highlight
        clearTimeout(validationTimeout);
        validationTimeout = setTimeout(() => scheduleServerParse(code, docVersion), PARSE_DEBOUNCE_MS);
    }

    function updateOverlayFast(code) {
        // If we have existing HTML highlighting, try to preserve it intelligently
        if (lastHighlightedCode && code.startsWith(lastCode)) {
            // User is typing at the end - append new text
            const newText = code.substring(lastCode.length);
            if (newText) {
                const span = document.createElement('span');
                span.className = 'token-default';
                span.textContent = newText;
                highlightedCode.appendChild(span);
            }
        } else if (lastHighlightedCode && lastCode.startsWith(code)) {
            // User is deleting from the end - trim overlay
            const textContent = highlightedCode.textContent || '';
            if (textContent.length > code.length) {
                highlightedCode.textContent = code;
            }
        } else {
            // Major change (paste, delete middle, etc) - show all as plain text
            highlightedCode.textContent = code;
        }
        lastCode = code;
    }


    runButton.addEventListener('click', runCode);

    function renderStatus(message, kind) {
        const cls = kind === 'error' ? 'validation-error'
            : kind === 'success' ? 'validation-success'
                : 'validation-loading';

        // Parse error messages and make them clickable
        let htmlContent = escapeHtml(message);
        if (kind === 'error') {
            htmlContent = parseErrorMessages(htmlContent);
        }

        errorPanel.innerHTML = `<div class="validation-message ${cls}">${htmlContent}</div>`;
    }

    function parseErrorMessages(text) {
        let result = text;

        // Pattern 1: <file>:<line>:<column>: error: <message> (entire line)
        // These use 1-based indexing
        const fileErrorPattern = /^(.+?):(\d+):(\d+):\s*error:.*$/gm;
        result = result.replace(fileErrorPattern, (match, file, line, column) => {
            return `<span class="error-link" onclick="navigateToError(${line}, ${column}, true); event.stopPropagation(); return false;">${escapeHtml(match)}</span>`;
        });

        // Pattern 2: Line <line>:<column> <message> (entire line)
        // ANTLR errors use 1-based line but 0-based column
        const lineErrorPattern = /^(Line\s+(\d+):(\d+)\s+.*)$/gm;
        result = result.replace(lineErrorPattern, (match, fullMatch, line, column) => {
            return `<span class="error-link" onclick="navigateToError(${line}, ${column}, false); event.stopPropagation(); return false;">${escapeHtml(match)}</span>`;
        });

        return result;
    }

    function navigateToError(line, column, isOneBased = true) {
        const code = codeEditor.value;
        const lines = code.split('\n');

        // Validate line and column numbers
        // Line is always 1-based in error messages, column may be 0-based or 1-based
        const lineIndex = parseInt(line) - 1;
        const columnIndex = isOneBased ? parseInt(column) - 1 : parseInt(column);

        if (lineIndex < 0 || lineIndex >= lines.length) {
            console.error('Invalid line number:', line);
            return;
        }

        // Calculate the character position in the textarea
        let position = 0;
        for (let i = 0; i < lineIndex; i++) {
            position += lines[i].length + 1; // +1 for newline character
        }
        position += Math.max(0, Math.min(columnIndex, lines[lineIndex].length));

        // Set cursor position and focus
        codeEditor.focus();
        codeEditor.setSelectionRange(position, position);

        // Scroll the editor to make the error visible
        scrollToPosition(lineIndex);

        // Highlight the error location
        highlightErrorLocation(lineIndex, columnIndex);
    }

    function scrollToPosition(lineIndex) {
        // Calculate approximate scroll position
        const lineHeight = parseFloat(getComputedStyle(codeEditor).lineHeight) || 21; // 1.5 * 14px
        const scrollTop = lineIndex * lineHeight - (codeEditor.clientHeight / 2);

        codeEditor.scrollTop = Math.max(0, scrollTop);
        highlightedCode.scrollTop = codeEditor.scrollTop;
        highlightedCode.scrollLeft = codeEditor.scrollLeft;
    }

    function clearPreviousErrorHighlights() {
        // Remove all existing error-highlight spans from the highlighted code
        const errorHighlights = highlightedCode.querySelectorAll('.error-highlight');
        errorHighlights.forEach(span => {
            // Replace the span with its text content
            const textNode = document.createTextNode(span.textContent);
            span.parentNode.replaceChild(textNode, span);
        });

        // Normalize the parent to merge adjacent text nodes
        if (highlightedCode.childNodes.length > 0) {
            highlightedCode.normalize();
        }
    }

    function highlightErrorLocation(lineIndex, columnIndex) {
        // Clear any previous error highlights first
        clearPreviousErrorHighlights();

        const code = codeEditor.value;
        const lines = code.split('\n');

        if (lineIndex < 0 || lineIndex >= lines.length) return;

        // Find the token or word at this position to highlight
        const line = lines[lineIndex];
        let startCol = columnIndex;
        let endCol = columnIndex;

        // Expand to cover the token/word
        while (startCol > 0 && /\S/.test(line[startCol - 1])) {
            startCol--;
        }
        while (endCol < line.length && /\S/.test(line[endCol])) {
            endCol++;
        }

        // If no word found, highlight at least one character
        if (startCol === endCol && endCol < line.length) {
            endCol++;
        }

        // Calculate absolute positions in the code
        let startPos = 0;
        for (let i = 0; i < lineIndex; i++) {
            startPos += lines[i].length + 1;
        }
        const highlightStart = startPos + startCol;
        const highlightEnd = startPos + endCol;

        // Get the current HTML content and wrap the error location with highlight span
        // We need to traverse the existing HTML and find the text position
        const currentHTML = highlightedCode.innerHTML;

        // If we have existing syntax highlighting, preserve it
        if (currentHTML && currentHTML.includes('<span')) {
            // Use a temporary div to parse the HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentHTML;

            // Find and wrap the error position
            let textPosition = 0;
            let found = false;

            function traverseAndHighlight(node) {
                if (found) return;

                if (node.nodeType === Node.TEXT_NODE) {
                    const text = node.textContent || '';
                    const nodeStart = textPosition;
                    const nodeEnd = textPosition + text.length;

                    if (highlightStart >= nodeStart && highlightStart < nodeEnd) {
                        // The highlight starts in this text node
                        const offsetStart = highlightStart - nodeStart;
                        const offsetEnd = Math.min(highlightEnd - nodeStart, text.length);

                        const before = text.substring(0, offsetStart);
                        const highlighted = text.substring(offsetStart, offsetEnd);
                        const after = text.substring(offsetEnd);

                        const fragment = document.createDocumentFragment();
                        if (before) fragment.appendChild(document.createTextNode(before));

                        const highlightSpan = document.createElement('span');
                        highlightSpan.className = 'error-highlight';
                        highlightSpan.textContent = highlighted;
                        fragment.appendChild(highlightSpan);

                        if (after) fragment.appendChild(document.createTextNode(after));

                        node.parentNode.replaceChild(fragment, node);
                        found = true;
                        return;
                    }

                    textPosition += text.length;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    // Traverse children
                    const children = Array.from(node.childNodes);
                    for (const child of children) {
                        traverseAndHighlight(child);
                        if (found) return;
                    }
                }
            }

            traverseAndHighlight(tempDiv);

            if (found) {
                highlightedCode.innerHTML = tempDiv.innerHTML;
            } else {
                // Fallback: couldn't find position in HTML, just add a simple highlight
                addSimpleHighlight(code, highlightStart, highlightEnd);
            }
        } else {
            // No syntax highlighting yet, use simple text highlighting
            addSimpleHighlight(code, highlightStart, highlightEnd);
        }

        // Note: We don't trigger re-parse here to avoid clearing the error messages
        // The highlight will fade naturally via CSS animation
    }

    function addSimpleHighlight(code, highlightStart, highlightEnd) {
        const before = code.substring(0, highlightStart);
        const highlight = code.substring(highlightStart, highlightEnd);
        const after = code.substring(highlightEnd);

        highlightedCode.innerHTML =
            escapeHtml(before) +
            `<span class="error-highlight">${escapeHtml(highlight)}</span>` +
            escapeHtml(after);
    }


    function scheduleServerParse(code, version) {
        // Abort any in-flight parse
        if (currentController) { try { currentController.abort(); } catch(_){} }
        currentController = new AbortController();
        const signal = currentController.signal;

        // Use idle time if available
        const doFetch = () => {
            renderStatus('Validating code...', 'loading');
            fetch('/validate-code', {
                method: 'POST', headers: {'Content-Type': 'text/plain'}, body: code, signal
            })
                .then(r => r.json())
                .then(json => {
                    if (version !== docVersion) return; // stale result; ignore
                    if (!json || !Array.isArray(json.tokens)) {
                        highlightedCode.innerHTML = `<span class="token-error">${escapeHtml(code)}</span>`;
                        renderStatus('✗ Parser returned invalid result', 'error');
                        return;
                    }
                    if (json.hasErrors) {
                        applyHighlight(code, json.tokens, json.errorLocations || []);
                        const errs = (json.errors || []).join('\n');
                        renderStatus(`✗ Parsing errors\n${errs}`, 'error');
                        return;
                    }
                    applyHighlight(code, json.tokens);
                    renderStatus('✓ Code is valid', 'success');
                })
                .catch(err => {
                    if (signal.aborted) return; // ignore aborted requests
                    if (version !== docVersion) return;
                    highlightedCode.innerHTML = `<span class="token-error">${escapeHtml(code)}</span>`;
                    renderStatus(`✗ ${String(err)}`, 'error');
                });
        };

        if ('requestIdleCallback' in window) {
            requestIdleCallback(doFetch, { timeout: PARSE_DEBOUNCE_MS });
        } else {
            setTimeout(doFetch, 0);
        }
    }

    function applyHighlight(code, tokens, errorLocations = []) {
        // Build linear index for each token
        const lineOffsets = [];
        let offset = 0; const lines = code.split('\n');
        for (let i = 0; i < lines.length; i++) { lineOffsets[i + 1] = offset; offset += lines[i].length + 1; }

        const errorLines = new Set(errorLocations.map(err => err.line));

        let html = ''; let last = 0;
        const sorted = tokens.slice().sort((a,b)=> a.line - b.line || a.column - b.column);
        for (const t of sorted) {
            const pos = (lineOffsets[t.line] ?? 0) + (t.column ?? 0);
            if (pos > last) html += escapeHtml(code.slice(last, pos));

            const cls = errorLines.has(t.line) ? 'token-error' : `token-${t.type || 'default'}`;
            const text = code.substr(pos, t.text?.length ?? 0);
            html += `<span class="${cls}">${escapeHtml(text)}</span>`;
            last = pos + (t.text?.length ?? 0);
        }
        if (last < code.length) html += escapeHtml(code.slice(last));
        highlightedCode.innerHTML = html;
        lastHighlightedCode = code;
        lastCode = code;
    }

    async function runCode() {
        const code = codeEditor.value;
        if (!code.trim()) {
            resultPanel.innerHTML = '<div class="validation-message validation-error">✗ Please enter some code first</div>';
            return;
        }

        // Show loading spinner
        resultPanel.innerHTML = `
            <div class="loading-container">
                <div class="loading-spinner"></div>
                <div class="loading-text">Running code...</div>
            </div>
        `;

        try {
            const response = await fetch('/run-code', {
                method: 'POST',
                headers: {'Content-Type': 'text/plain'},
                body: code
            });

            if (!response.ok) {
                resultPanel.innerHTML = '<div class="validation-message validation-error">✗ Error running code</div>';
                return;
            }

            // Replace loading spinner with output container
            resultPanel.innerHTML = '<div id="runResult" style="font-family: monospace; white-space: pre-wrap;"></div>';
            const runResult = document.getElementById('runResult');

            // Get the reader from the response body stream
            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            let accumulatedText = '';

            // Read the stream chunk by chunk
            while (true) {
                const { done, value } = await reader.read();

                if (done) {
                    break;
                }

                // Decode the chunk and append to accumulated text
                const chunk = decoder.decode(value, { stream: true });
                accumulatedText += chunk;

                // Update the display with clickable error links
                runResult.innerHTML = parseErrorMessages(escapeHtml(accumulatedText));

                // Auto-scroll to bottom to show latest output
                resultPanel.scrollTop = resultPanel.scrollHeight;
            }

            // Final update after stream is complete
            runResult.innerHTML = parseErrorMessages(escapeHtml(accumulatedText));

        } catch (e) {
            resultPanel.innerHTML = `<div class="validation-message validation-error">✗ ${escapeHtml(String(e))}</div>`;
        }
    }

    function escapeHtml(text) {
        const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
        return String(text).replace(/[&<>"']/g, m => map[m]);
    }
</script>
</body>
</html>
